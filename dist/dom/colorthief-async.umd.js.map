{"version":3,"file":"colorthief-async.umd.js","sources":["../../node_modules/quantize/dist/index.mjs","../../src/color-thief.dom.ts","../../src/shared.ts"],"sourcesContent":["/*\r\n * quantize.js Copyright 2008 Nick Rabinowitz\r\n * Ported to node.js by Olivier Lesnicki\r\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\r\n */\r\n// fill out a couple protovis dependencies\r\n\r\n/*\r\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\r\n * Copyright 2010 Stanford Visualization Group\r\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\r\n */\r\nif (!pv) {\r\n  var pv = {\r\n    map: function (array, f) {\r\n      var o = {};\r\n      return f ? array.map(function (d, i) {\r\n        o.index = i;\r\n        return f.call(o, d);\r\n      }) : array.slice();\r\n    },\r\n    naturalOrder: function (a, b) {\r\n      return a < b ? -1 : a > b ? 1 : 0;\r\n    },\r\n    sum: function (array, f) {\r\n      var o = {};\r\n      return array.reduce(f ? function (p, d, i) {\r\n        o.index = i;\r\n        return p + f.call(o, d);\r\n      } : function (p, d) {\r\n        return p + d;\r\n      }, 0);\r\n    },\r\n    max: function (array, f) {\r\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\r\n    }\r\n  };\r\n}\r\n/**\r\n * Basic Javascript port of the MMCQ (modified median cut quantization)\r\n * algorithm from the Leptonica library (http://www.leptonica.com/).\r\n * Returns a color map you can use to map original pixels to the reduced\r\n * palette. Still a work in progress.\r\n * \r\n * @author Nick Rabinowitz\r\n * @example\r\n \r\n// array of pixels as [R,G,B] arrays\r\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\r\n                // etc\r\n                ];\r\nvar maxColors = 4;\r\n \r\nvar cmap = MMCQ.quantize(myPixels, maxColors);\r\nvar newPalette = cmap.palette();\r\nvar newPixels = myPixels.map(function(p) { \r\n    return cmap.map(p); \r\n});\r\n \r\n */\r\n\r\n\r\nvar MMCQ = function () {\r\n  // private constants\r\n  var sigbits = 5,\r\n      rshift = 8 - sigbits,\r\n      maxIterations = 1000,\r\n      fractByPopulations = 0.75; // get reduced-space color index for a pixel\r\n\r\n  function getColorIndex(r, g, b) {\r\n    return (r << 2 * sigbits) + (g << sigbits) + b;\r\n  } // Simple priority queue\r\n\r\n\r\n  function PQueue(comparator) {\r\n    var contents = [],\r\n        sorted = false;\r\n\r\n    function sort() {\r\n      contents.sort(comparator);\r\n      sorted = true;\r\n    }\r\n\r\n    return {\r\n      push: function (o) {\r\n        contents.push(o);\r\n        sorted = false;\r\n      },\r\n      peek: function (index) {\r\n        if (!sorted) { sort(); }\r\n        if (index === undefined) { index = contents.length - 1; }\r\n        return contents[index];\r\n      },\r\n      pop: function () {\r\n        if (!sorted) { sort(); }\r\n        return contents.pop();\r\n      },\r\n      size: function () {\r\n        return contents.length;\r\n      },\r\n      map: function (f) {\r\n        return contents.map(f);\r\n      },\r\n      debug: function () {\r\n        if (!sorted) { sort(); }\r\n        return contents;\r\n      }\r\n    };\r\n  } // 3d color space box\r\n\r\n\r\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\r\n    var vbox = this;\r\n    vbox.r1 = r1;\r\n    vbox.r2 = r2;\r\n    vbox.g1 = g1;\r\n    vbox.g2 = g2;\r\n    vbox.b1 = b1;\r\n    vbox.b2 = b2;\r\n    vbox.histo = histo;\r\n  }\r\n\r\n  VBox.prototype = {\r\n    volume: function (force) {\r\n      var vbox = this;\r\n\r\n      if (!vbox._volume || force) {\r\n        vbox._volume = (vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1);\r\n      }\r\n\r\n      return vbox._volume;\r\n    },\r\n    count: function (force) {\r\n      var vbox = this,\r\n          histo = vbox.histo;\r\n\r\n      if (!vbox._count_set || force) {\r\n        var npix = 0,\r\n            i,\r\n            j,\r\n            k,\r\n            index;\r\n\r\n        for (i = vbox.r1; i <= vbox.r2; i++) {\r\n          for (j = vbox.g1; j <= vbox.g2; j++) {\r\n            for (k = vbox.b1; k <= vbox.b2; k++) {\r\n              index = getColorIndex(i, j, k);\r\n              npix += histo[index] || 0;\r\n            }\r\n          }\r\n        }\r\n\r\n        vbox._count = npix;\r\n        vbox._count_set = true;\r\n      }\r\n\r\n      return vbox._count;\r\n    },\r\n    copy: function () {\r\n      var vbox = this;\r\n      return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\r\n    },\r\n    avg: function (force) {\r\n      var vbox = this,\r\n          histo = vbox.histo;\r\n\r\n      if (!vbox._avg || force) {\r\n        var ntot = 0,\r\n            mult = 1 << 8 - sigbits,\r\n            rsum = 0,\r\n            gsum = 0,\r\n            bsum = 0,\r\n            hval,\r\n            i,\r\n            j,\r\n            k,\r\n            histoindex;\r\n\r\n        for (i = vbox.r1; i <= vbox.r2; i++) {\r\n          for (j = vbox.g1; j <= vbox.g2; j++) {\r\n            for (k = vbox.b1; k <= vbox.b2; k++) {\r\n              histoindex = getColorIndex(i, j, k);\r\n              hval = histo[histoindex] || 0;\r\n              ntot += hval;\r\n              rsum += hval * (i + 0.5) * mult;\r\n              gsum += hval * (j + 0.5) * mult;\r\n              bsum += hval * (k + 0.5) * mult;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (ntot) {\r\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\r\n        } else {\r\n          //console.log('empty box');\r\n          vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];\r\n        }\r\n      }\r\n\r\n      return vbox._avg;\r\n    },\r\n    contains: function (pixel) {\r\n      var vbox = this,\r\n          rval = pixel[0] >> rshift;\r\n      gval = pixel[1] >> rshift;\r\n      bval = pixel[2] >> rshift;\r\n      return rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && gval <= vbox.g2 && bval >= vbox.b1 && bval <= vbox.b2;\r\n    }\r\n  }; // Color map\r\n\r\n  function CMap() {\r\n    this.vboxes = new PQueue(function (a, b) {\r\n      return pv.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());\r\n    });\r\n  }\r\n\r\n  CMap.prototype = {\r\n    push: function (vbox) {\r\n      this.vboxes.push({\r\n        vbox: vbox,\r\n        color: vbox.avg()\r\n      });\r\n    },\r\n    palette: function () {\r\n      return this.vboxes.map(function (vb) {\r\n        return vb.color;\r\n      });\r\n    },\r\n    size: function () {\r\n      return this.vboxes.size();\r\n    },\r\n    map: function (color) {\r\n      var vboxes = this.vboxes;\r\n\r\n      for (var i = 0; i < vboxes.size(); i++) {\r\n        if (vboxes.peek(i).vbox.contains(color)) {\r\n          return vboxes.peek(i).color;\r\n        }\r\n      }\r\n\r\n      return this.nearest(color);\r\n    },\r\n    nearest: function (color) {\r\n      var vboxes = this.vboxes,\r\n          d1,\r\n          d2,\r\n          pColor;\r\n\r\n      for (var i = 0; i < vboxes.size(); i++) {\r\n        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));\r\n\r\n        if (d2 < d1 || d1 === undefined) {\r\n          d1 = d2;\r\n          pColor = vboxes.peek(i).color;\r\n        }\r\n      }\r\n\r\n      return pColor;\r\n    },\r\n    forcebw: function () {\r\n      // XXX: won't  work yet\r\n      var vboxes = this.vboxes;\r\n      vboxes.sort(function (a, b) {\r\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));\r\n      }); // force darkest color to black if everything < 5\r\n\r\n      var lowest = vboxes[0].color;\r\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5) { vboxes[0].color = [0, 0, 0]; } // force lightest color to white if everything > 251\r\n\r\n      var idx = vboxes.length - 1,\r\n          highest = vboxes[idx].color;\r\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) { vboxes[idx].color = [255, 255, 255]; }\r\n    }\r\n  }; // histo (1-d array, giving the number of pixels in\r\n  // each quantized region of color space), or null on error\r\n\r\n  function getHisto(pixels) {\r\n    var histosize = 1 << 3 * sigbits,\r\n        histo = new Array(histosize),\r\n        index,\r\n        rval,\r\n        gval,\r\n        bval;\r\n    pixels.forEach(function (pixel) {\r\n      rval = pixel[0] >> rshift;\r\n      gval = pixel[1] >> rshift;\r\n      bval = pixel[2] >> rshift;\r\n      index = getColorIndex(rval, gval, bval);\r\n      histo[index] = (histo[index] || 0) + 1;\r\n    });\r\n    return histo;\r\n  }\r\n\r\n  function vboxFromPixels(pixels, histo) {\r\n    var rmin = 1000000,\r\n        rmax = 0,\r\n        gmin = 1000000,\r\n        gmax = 0,\r\n        bmin = 1000000,\r\n        bmax = 0,\r\n        rval,\r\n        gval,\r\n        bval; // find min/max\r\n\r\n    pixels.forEach(function (pixel) {\r\n      rval = pixel[0] >> rshift;\r\n      gval = pixel[1] >> rshift;\r\n      bval = pixel[2] >> rshift;\r\n      if (rval < rmin) { rmin = rval; }else if (rval > rmax) { rmax = rval; }\r\n      if (gval < gmin) { gmin = gval; }else if (gval > gmax) { gmax = gval; }\r\n      if (bval < bmin) { bmin = bval; }else if (bval > bmax) { bmax = bval; }\r\n    });\r\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\r\n  }\r\n\r\n  function medianCutApply(histo, vbox) {\r\n    if (!vbox.count()) { return; }\r\n    var rw = vbox.r2 - vbox.r1 + 1,\r\n        gw = vbox.g2 - vbox.g1 + 1,\r\n        bw = vbox.b2 - vbox.b1 + 1,\r\n        maxw = pv.max([rw, gw, bw]); // only one pixel, no split\r\n\r\n    if (vbox.count() == 1) {\r\n      return [vbox.copy()];\r\n    }\r\n    /* Find the partial sum arrays along the selected axis. */\r\n\r\n\r\n    var total = 0,\r\n        partialsum = [],\r\n        lookaheadsum = [],\r\n        i,\r\n        j,\r\n        k,\r\n        sum,\r\n        index;\r\n\r\n    if (maxw == rw) {\r\n      for (i = vbox.r1; i <= vbox.r2; i++) {\r\n        sum = 0;\r\n\r\n        for (j = vbox.g1; j <= vbox.g2; j++) {\r\n          for (k = vbox.b1; k <= vbox.b2; k++) {\r\n            index = getColorIndex(i, j, k);\r\n            sum += histo[index] || 0;\r\n          }\r\n        }\r\n\r\n        total += sum;\r\n        partialsum[i] = total;\r\n      }\r\n    } else if (maxw == gw) {\r\n      for (i = vbox.g1; i <= vbox.g2; i++) {\r\n        sum = 0;\r\n\r\n        for (j = vbox.r1; j <= vbox.r2; j++) {\r\n          for (k = vbox.b1; k <= vbox.b2; k++) {\r\n            index = getColorIndex(j, i, k);\r\n            sum += histo[index] || 0;\r\n          }\r\n        }\r\n\r\n        total += sum;\r\n        partialsum[i] = total;\r\n      }\r\n    } else {\r\n      /* maxw == bw */\r\n      for (i = vbox.b1; i <= vbox.b2; i++) {\r\n        sum = 0;\r\n\r\n        for (j = vbox.r1; j <= vbox.r2; j++) {\r\n          for (k = vbox.g1; k <= vbox.g2; k++) {\r\n            index = getColorIndex(j, k, i);\r\n            sum += histo[index] || 0;\r\n          }\r\n        }\r\n\r\n        total += sum;\r\n        partialsum[i] = total;\r\n      }\r\n    }\r\n\r\n    partialsum.forEach(function (d, i) {\r\n      lookaheadsum[i] = total - d;\r\n    });\r\n\r\n    function doCut(color) {\r\n      var dim1 = color + '1',\r\n          dim2 = color + '2',\r\n          left,\r\n          right,\r\n          vbox1,\r\n          vbox2,\r\n          d2,\r\n          count2 = 0;\r\n\r\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\r\n        if (partialsum[i] > total / 2) {\r\n          vbox1 = vbox.copy();\r\n          vbox2 = vbox.copy();\r\n          left = i - vbox[dim1];\r\n          right = vbox[dim2] - i;\r\n          if (left <= right) { d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2)); }else { d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2)); } // avoid 0-count boxes\r\n\r\n          while (!partialsum[d2]) { d2++; }\r\n\r\n          count2 = lookaheadsum[d2];\r\n\r\n          while (!count2 && partialsum[d2 - 1]) { count2 = lookaheadsum[--d2]; } // set dimensions\r\n\r\n\r\n          vbox1[dim2] = d2;\r\n          vbox2[dim1] = vbox1[dim2] + 1; // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\r\n\r\n          return [vbox1, vbox2];\r\n        }\r\n      }\r\n    } // determine the cut planes\r\n\r\n\r\n    return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');\r\n  }\r\n\r\n  function quantize(pixels, maxcolors) {\r\n    // short-circuit\r\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\r\n      // console.log('wrong number of maxcolors');\r\n      return false;\r\n    } // XXX: check color content and convert to grayscale if insufficient\r\n\r\n\r\n    var histo = getHisto(pixels);\r\n // check that we aren't below maxcolors already\r\n    histo.forEach(function () {\r\n    });\r\n    // get the beginning vbox from the colors\r\n\r\n\r\n    var vbox = vboxFromPixels(pixels, histo),\r\n        pq = new PQueue(function (a, b) {\r\n      return pv.naturalOrder(a.count(), b.count());\r\n    });\r\n    pq.push(vbox); // inner function to do the iteration\r\n\r\n    function iter(lh, target) {\r\n      var ncolors = lh.size(),\r\n          niters = 0,\r\n          vbox;\r\n\r\n      while (niters < maxIterations) {\r\n        if (ncolors >= target) { return; }\r\n\r\n        if (niters++ > maxIterations) {\r\n          // console.log(\"infinite loop; perhaps too few pixels!\");\r\n          return;\r\n        }\r\n\r\n        vbox = lh.pop();\r\n\r\n        if (!vbox.count()) {\r\n          /* just put it back */\r\n          lh.push(vbox);\r\n          niters++;\r\n          continue;\r\n        } // do the cut\r\n\r\n\r\n        var vboxes = medianCutApply(histo, vbox),\r\n            vbox1 = vboxes[0],\r\n            vbox2 = vboxes[1];\r\n\r\n        if (!vbox1) {\r\n          // console.log(\"vbox1 not defined; shouldn't happen!\");\r\n          return;\r\n        }\r\n\r\n        lh.push(vbox1);\r\n\r\n        if (vbox2) {\r\n          /* vbox2 can be null */\r\n          lh.push(vbox2);\r\n          ncolors++;\r\n        }\r\n      }\r\n    } // first set of colors, sorted by population\r\n\r\n\r\n    iter(pq, fractByPopulations * maxcolors); // console.log(pq.size(), pq.debug().length, pq.debug().slice());\r\n    // Re-sort by the product of pixel occupancy times the size in color space.\r\n\r\n    var pq2 = new PQueue(function (a, b) {\r\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\r\n    });\r\n\r\n    while (pq.size()) {\r\n      pq2.push(pq.pop());\r\n    } // next set - generate the median cuts using the (npix * vol) sorting.\r\n\r\n\r\n    iter(pq2, maxcolors); // calculate the actual colors\r\n\r\n    var cmap = new CMap();\r\n\r\n    while (pq2.size()) {\r\n      cmap.push(pq2.pop());\r\n    }\r\n\r\n    return cmap;\r\n  }\r\n\r\n  return {\r\n    quantize: quantize\r\n  };\r\n}();\r\n\r\nvar quantize = MMCQ.quantize;\r\n\r\nexport default quantize;\r\n","\nimport {getPaletteFromImageData} from './shared';\nimport {ColorCallback, ColorRGB, ColorThiefOptions, PaletteCallback} from \"./models\";\n// @ts-ignore\nimport quantize from '../node_modules/quantize';\n/*\n * Color Thief Async v2.3.0\n * Originally by Lokesh Dhakar - http://www.lokeshdhakar.com\n *\n * Thanks\n * ------\n * Nick Rabinowitz - For creating quantize.js.\n * John Schulz - For clean up and optimization. @JFSIII\n * Nathan Spady - For adding drag and drop support to the demo page.\n *\n * License\n * -------\n * Released under the MIT license\n * https://raw.githubusercontent.com/piksel/color-thief/master/LICENSE\n *\n * @license\n */\n\ntype Source = CanvasImageSource | string;\n\n\n\n    /*\n     * getColor(sourceImage[, quality, [, callback]])\n     * returns Promise<{r: num, g: num, b: num}>\n     *\n     * Use the median cut algorithm provided by quantize.js to cluster similar\n     * colors and return the base color from the largest cluster.\n     *\n     * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n     * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n     * faster a color will be returned but the greater the likelihood that it will not be the visually\n     * most dominant color.\n     *\n     * */\n    export const getColor = (sourceImage: Source, quality: number, callback: ColorCallback): Promise<ColorRGB> =>\n        getPaletteFromSource(sourceImage, {quality, colorCount: 5}).then(palette => {\n            callback && callback(palette[0]);\n            return palette[0];\n        });\n\n    /*\n     * getPalette(sourceImage[, { colorCount, quality}, [callback]])\n     * returns Promise< [ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...] >\n     *\n     * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n     *\n     * colorCount determines the size of the palette; the number of colors returned. If not set, it\n     * defaults to 10.\n     *\n     * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n     * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n     * faster the palette generation but the greater the likelihood that colors will be missed.\n     *\n     *\n     */\n    export const getPalette = (sourceImage: Source, options?: ColorThiefOptions, callback?: PaletteCallback) =>\n        getPaletteFromSource(sourceImage, options).then(palette => {\n                callback && callback(palette);\n            return palette;\n        });\n\n\nconst getPaletteFromSource = (sourceImage: Source, options?: ColorThiefOptions): Promise<ColorRGB[]> =>\n    getCanvasSource(sourceImage).then(canvasSource => {\n        const imageData = dataFromImage(canvasSource);\n        const palette = getPaletteFromImageData(imageData, quantize, options);\n        if(!palette) {\n            throw new Error('Failed to get image color palette');\n        }\n        return palette;\n    });\n\nconst dataFromImage = (image: CanvasImageSource) => {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    if(context == null) {\n        throw new Error('Failed to get canvas context')\n    }\n    const width = canvas.width = getSourceSize(image.width);\n    const height = canvas.height = getSourceSize(image.height);\n    context.drawImage(image, 0, 0, width, height);\n    return context.getImageData(0, 0, width, height);\n};\n\nconst getCanvasSource = (imageSource: CanvasImageSource | string): Promise<CanvasImageSource> => new Promise((resolve, reject) => {\n    if((typeof imageSource === 'string')) {\n        const timeout = setTimeout(() => {\n            reject('Timed out waiting for image to load');\n        }, 10000);\n        const imageElement = document.createElement(\"img\");\n        imageElement.addEventListener('load', () => {\n            clearTimeout(timeout);\n            resolve(imageElement);\n        });\n        imageElement.src = imageSource;\n    }\n    else {\n        resolve(imageSource);\n    }\n});\n\nconst getSourceSize = (value: number | SVGAnimatedLength): number =>\n    typeof value !== 'number'  ? value.baseVal.value : value;\n","import {ColorRGB, ColorThiefOptions} from \"./models\";\n\n\n\nexport const createPixelArray = (imgData: Uint8ClampedArray, pixelCount: number, quality: number) => {\n    const pixels = imgData;\n    const pixelArray = [];\n\n    for (let i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n        offset = i * 4;\n        r = pixels[offset + 0];\n        g = pixels[offset + 1];\n        b = pixels[offset + 2];\n        a = pixels[offset + 3];\n\n        // If pixel is mostly opaque and not white\n        if (typeof a === 'undefined' || a >= 125) {\n            if (!(r > 250 && g > 250 && b > 250)) {\n                pixelArray.push([r, g, b]);\n            }\n        }\n    }\n    return pixelArray;\n};\n\nexport const validateOptions = (options?: Partial<ColorThiefOptions>): ColorThiefOptions => {\n    let { colorCount, quality } = options || {};\n\n    if (typeof colorCount === 'undefined' || !Number.isInteger(colorCount)) {\n        colorCount = 10;\n    } else if (colorCount === 1 ) {\n        throw new Error('colorCount should be between 2 and 20. To get one color, call getColor() instead of getPalette()');\n    } else {\n        colorCount = Math.max(colorCount, 2);\n        colorCount = Math.min(colorCount, 20);\n    }\n\n    if (typeof quality === 'undefined' || Number.isInteger(quality)) {\n        quality = 10;\n    } else if (quality < 1) {\n        quality = 10;\n    }\n\n    return {\n        colorCount,\n        quality\n    }\n}\n\nexport const getPaletteFromImageData = (imageData: ImageData, quantize: any, options?: Partial<ColorThiefOptions>): ColorRGB[] | null => {\n    const {\n        colorCount,\n        quality\n    } = validateOptions(options);\n\n    const pixelCount = imageData.width * imageData.height;\n\n    const pixelArray = createPixelArray(imageData.data, pixelCount, quality);\n\n    // Send array to quantize function which clusters values\n    // using median cut algorithm\n    const cmap = quantize(pixelArray, colorCount);\n    return cmap ? cmap.palette() : null;\n}\n"],"names":["pv","map","array","f","o","d","i","index","call","slice","naturalOrder","a","b","sum","reduce","p","max","Math","apply","quantize","sigbits","rshift","maxIterations","getColorIndex","r","g","PQueue","comparator","contents","sorted","sort","push","peek","undefined","length","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","this","CMap","vboxes","vbox","count","volume","medianCutApply","rw","gw","maxw","copy","j","k","total","partialsum","lookaheadsum","forEach","color","left","right","vbox1","vbox2","d2","dim1","dim2","count2","min","doCut","prototype","force","_volume","_count_set","npix","_count","avg","_avg","hval","ntot","mult","rsum","gsum","bsum","contains","pixel","rval","gval","bval","palette","vb","nearest","d1","pColor","sqrt","pow","forcebw","lowest","idx","highest","pixels","maxcolors","Array","getHisto","rmin","rmax","gmin","gmax","bmin","bmax","vboxFromPixels","pq","iter","lh","target","ncolors","niters","pq2","cmap","getPaletteFromSource","sourceImage","options","getCanvasSource","then","canvasSource","imageData","colorCount","Number","isInteger","Error","quality","validateOptions","imgData","pixelCount","data","pixelArray","offset","createPixelArray","width","height","getPaletteFromImageData","dataFromImage","image","canvas","document","createElement","context","getContext","getSourceSize","drawImage","getImageData","imageSource","Promise","resolve","reject","timeout","setTimeout","imageElement","addEventListener","clearTimeout","src","value","baseVal","callback"],"mappings":"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"}